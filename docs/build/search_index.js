var documenterSearchIndex = {"docs":
[{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = SafeSelfTriggered","category":"page"},{"location":"index.html#SafeSelfTriggered","page":"Home","title":"SafeSelfTriggered","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Documentation for SafeSelfTriggered.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Modules = [SafeSelfTriggered]","category":"page"},{"location":"index.html#SafeSelfTriggered.ComplexZonotope","page":"Home","title":"SafeSelfTriggered.ComplexZonotope","text":"Type: ComplexZonotope{N<:Real, M<:Number}(center::Vector{N}, generators::Matrix{M}, scale_vector::Vector{N})\n\nComplex Zonotope is a set representation for some convex sets containing complex valued vectors.\nIt is an extension of the simple zonotope representation to complex numbers.\nIts real projection can however be a non-polytopic set, unlike a simple zonotope which is polytopic.\n\nLet c be a real vector, G be a complex matrix and s be a positive real vector. Then\nComplexZonotope(c,G,s) = Set{c + G\\zeta: \\zeta is complex vector, |\\zeta| <= s}\n\nConstructor: ComplexZonotope(center,generators,scale_vector)\n\n\n\n\n\n","category":"type"},{"location":"index.html#SafeSelfTriggered.OfflineComputationOptions","page":"Home","title":"SafeSelfTriggered.OfflineComputationOptions","text":"\n\n\n\n","category":"type"},{"location":"index.html#SafeSelfTriggered.OfflineComputationOptions-Tuple{SafeSelfTriggered.SelfTriggeredLinearImpulsive}","page":"Home","title":"SafeSelfTriggered.OfflineComputationOptions","text":"\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.OfflineQuantities","page":"Home","title":"SafeSelfTriggered.OfflineQuantities","text":"struct OfflineQuantities\n    time_step ::Real\n    invariant ::ComplexZonotope{<:Real, <:Number}\n    scaling_matrix ::Matrix{<:Number}\n    state_scales ::Vector{<:Real}\n    error_scales ::Vector{<:Real}        \nend\n\nQuantities required to be computed offline.\n\nfields\n\ntime_step : time step for computing successive reachable sets \n\ninvariant : invariant complex zonotope used as template for encoding reachable sets\nscaling_matrix : matrix which maps a point to the maximum scale inside the complex zonotope\nstate_scales : sequence of reachable sets encoded by scalars, obtained by successive action of state action matrix  \nerror_scales : sequence of disturbance reachable sets encoded by scalars\n\n\n\n\n\n","category":"type"},{"location":"index.html#SafeSelfTriggered.OfflineQuantities-Union{Tuple{N}, Tuple{SelfTriggeredLinearControl{N}, Matrix{N}}, Tuple{SelfTriggeredLinearControl{N}, Matrix{N}, Vector{N}}} where N<:Real","page":"Home","title":"SafeSelfTriggered.OfflineQuantities","text":"OfflineQuantities(L::SelfTriggeredLinearControl{N}, Zinit::ComplexZonotope{N,M}, T::Matrix{N}, solver_options::SolverOptions=SolverOptions()) where {N<:Real, M<:Number} -> ::OfflineQuantitites\n\noffline pre-computation of quantities required for computing latter the online triggering time upper bound.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.SelfTriggeredLinearControl","page":"Home","title":"SafeSelfTriggered.SelfTriggeredLinearControl","text":"struct SelfTriggeredLinearControl{N<:Real}\n    A::Matrix{N} # state action matrix\n    B::Matrix{N} # control action matrix \n    E::Matrix{N} # disturbance action matrix \n    K::Matrix{N} # feedback gain matrix \n    tmin::N # minimum time elapsed before trigger\nend\n\nSpecification of Self Triggered Linear Control System\n\n\n\n\n\n","category":"type"},{"location":"index.html#SafeSelfTriggered.SelfTriggeredLinearImpulsive","page":"Home","title":"SafeSelfTriggered.SelfTriggeredLinearImpulsive","text":"Description of system:\n(t_i)_{i=0}^{\\infty}: Sequence of impulse times\nt_{i+1}-t_{i} \\in [tau{\\min},tau{\\max}]\nx(t): state of system at time t\ndx(t)/dt = Ax(t) + Ev(t) : \\maxi |v(t)|i \\leq 1,  if t\\in [t_i,t_{i+1})\nx(t_{i}) = Rt_{i}^{-} if i>1\n\nCode macros:\n\"A\" -> A,  \"R\"->R, \"E\" -> E, \"\\mu\" -> mu, \"tau{\\max}\" -> tmax, \"tau{\\min}\" -> tmin\n\nType: SelftriggeredLinearImpusive{N<:Number}[A::Matrix{N}, R::Matrix{N}, E::Matrix{N}, mu:Vector{N}, tmax::N, tmin::N]\n\nConstructor:\nSelftriggeredLinearImpulsive(A, T, E, tmin)\n\n\n\n\n\n","category":"type"},{"location":"index.html#SafeSelfTriggered.SolverOptions","page":"Home","title":"SafeSelfTriggered.SolverOptions","text":"mutable struct SolverOptions\n    sequence_length::Real\n    order_invariant_zonotope::Integer\n    order_error_zonotope::Integer\n    optimizer::Function\n    function SolverOptions(; sequence_length::Integer=100, order_invariant_zonotope::Integer=2, order_error_zonotope::Integer=10, optimizer::Function=Mosek.Optimizer)\n        return new(sequence_length, order_invariant_zonotope, order_error_zonotope, optimizer)\n    end\nend\n\ncontains options for computing offline the scalarized reachability sequences\n\nfields\n\nsequence_length : length of reachability sequences, default = 100\norder_invariant_zonotope : order of the invariant zonotope, default = 2\norder_error_zonotope : order of error zonotope used during computation, default = 10\noptimizer : Optimization solver used, default : Mosek.optimizer\n\nconstructor\n\nSolverOptions(; sequence_length::Integer=100, order_invariant_zonotope::Integer=2, order_error_zonotope::Integer=10, optimizer::Function=Mosek.Optimizer)\n\n\n\n\n\n","category":"type"},{"location":"index.html#Base.:*-Union{Tuple{M}, Tuple{N}, Tuple{L}, Tuple{Matrix{L}, SafeSelfTriggered.ComplexZonotope{N, M}}} where {L<:Number, N<:Real, M<:Number}","page":"Home","title":"Base.:*","text":"A*Z: where A::Matrix{L}, Z::ComplexZonotope{N,M}\n\ncomputes the complex zonotope obtained by pre-multiplying the complex zonotope Z with A.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.rand-Tuple{Type{SafeSelfTriggered.ComplexZonotope}, Integer, Integer}","page":"Home","title":"Base.rand","text":"rand(::ComplexZonotope, dim::Integer, numgen::Integer)\n\ncomputes a random complex zonotope of dimension <dim> and number of generators <numgen>.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.bloat_input-Union{Tuple{N}, Tuple{SafeSelfTriggered.SelfTriggeredLinearImpulsive{N}, Any}} where N<:Real","page":"Home","title":"SafeSelfTriggered.bloat_input","text":"\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.compare_computation_times-Tuple{Integer, SelfTriggeredLinearControl, Matrix{<:Real}, OfflineQuantities}","page":"Home","title":"SafeSelfTriggered.compare_computation_times","text":"\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.error_scale_sequence-Union{Tuple{M}, Tuple{N}, Tuple{SafeSelfTriggered.SelfTriggeredLinearImpulsive{N}, SafeSelfTriggered.ComplexZonotope{N, M}}} where {N<:Real, M<:Number}","page":"Home","title":"SafeSelfTriggered.error_scale_sequence","text":"error_scale_sequence(L::SelfTriggeredLinearImpulsive, Zinv::ComplexZonotope{N,M}, t::Real, l::Integer; order = 10) where {N<:Real, M<:Number}\n\ncomputes sequence of contractions required for inclusion inside an invariant complex zonotope of a sequence of disturbance input sets involved in computing reachable sets in successive time intervals.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.fast_inclusion_scale-Union{Tuple{M2}, Tuple{M1}, Tuple{N2}, Tuple{N1}, Tuple{SafeSelfTriggered.ComplexZonotope{N1, M1}, SafeSelfTriggered.ComplexZonotope{N2, M2}}} where {N1<:Real, N2<:Real, M1<:Number, M2<:Number}","page":"Home","title":"SafeSelfTriggered.fast_inclusion_scale","text":"fast_inclusion_scale(Z1::ComplexZonotope{N1, M1}, Z2::ComplexZonotope{N2,M2}) where {N1<:Real, N2<:Real, M1<:Number, M2<:Number}\n\nfunction computes the minimum amount of expansion required for a complex zonotope to contain another complex zonotope.\n\nLet Z1::ComplexZonotope(G1,c1,s1), Z2::ComplexZonotope(G2,c2,s2)\nThen inclusion_scale(Z1,c1,s1) = min lambda \\in \\reals_{>=0} s.t.\nZ2 \\subseteq ComplexZonotope(G1,c1,lambda*s1)\n\n\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.inclusion_scale-Union{Tuple{M2}, Tuple{M1}, Tuple{N2}, Tuple{N1}, Tuple{SafeSelfTriggered.ComplexZonotope{N1, M1}, SafeSelfTriggered.ComplexZonotope{N2, M2}}} where {N1<:Real, N2<:Real, M1<:Number, M2<:Number}","page":"Home","title":"SafeSelfTriggered.inclusion_scale","text":"inclusion_scale(Z1::ComplexZonotope{N1, M1}, Z2::ComplexZonotope{N2,M2}) where {N1<:Real, N2<:Real, M1<:Number, M2<:Number}\n\nfunction computes the minimum amount of expansion required for a complex zonotope to contain another complex zonotope.\n\nLet Z1::ComplexZonotope(G1,c1,s1), Z2::ComplexZonotope(G2,c2,s2)\nThen inclusion_scale(Z1,c1,s1) = min lambda \\in \\reals_{>=0} s.t.\nZ2 \\subseteq ComplexZonotope(G1,c1,lambda*s1)\n\n\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.large_invariant_zero_centered-Union{Tuple{M}, Tuple{N}, Tuple{SafeSelfTriggered.SelfTriggeredLinearImpulsive, SafeSelfTriggered.ComplexZonotope{N, M}, Matrix{N}}} where {N<:Real, M<:Number}","page":"Home","title":"SafeSelfTriggered.large_invariant_zero_centered","text":"\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.state_scale_sequence-Union{Tuple{M}, Tuple{N}, Tuple{SafeSelfTriggered.SelfTriggeredLinearImpulsive{N}, SafeSelfTriggered.ComplexZonotope{N, M}}} where {N<:Real, M<:Number}","page":"Home","title":"SafeSelfTriggered.state_scale_sequence","text":"state_scale_sequence(L::SelfTriggeredLinearImpulsive, Zinv::ComplexZonotope{N,M}, t::Real, l::Integer) where {N<:Real, M<:Number}\n\ncomputes sequence of contractions required for inclusion inside an invariant complex zonotope after transformation by a sequence of sets of transformation operators as {exp(A tau) | (i-1)t <= tau <= itau}_{i=1}^{infinity}. \n\n\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.trigger_time_upper_bound-Tuple{SafeSelfTriggered.SelfTriggeredLinearImpulsive, Vector{<:Real}, OfflineQuantities}","page":"Home","title":"SafeSelfTriggered.trigger_time_upper_bound","text":"trigger_time_upper_bound(L::SelfTriggeredLinearImpulsive{<:Real}, x::Vector{<:Real}, inctesstateaction::Matrix{<:Number}, t::Real, statescales::Vector{<:Real}, errorscales::Vector{<:Real})\n\ncomputes the upper bound on the time for next impulse\n\n\n\n\n\n","category":"method"},{"location":"index.html#SafeSelfTriggered.verify-Union{Tuple{N}, Tuple{Vector{N}, Matrix{N}, Matrix{N}, Integer, Matrix{N}}} where N<:Number","page":"Home","title":"SafeSelfTriggered.verify","text":"\n\n\n\n","category":"method"}]
}
